<?PHP

function isHTMX()
{
	$headers = getallheaders();
	return ($headers !== false && isset($headers['Hx-Request']) && boolval($headers['Hx-Request']) === true);
}

/**
 * Converts a number of seconds into a human readable format.
 *
 * @param integer $seconds
 * @return string
 */
function secondsToHumanTime(int $seconds): string
{
	if ($seconds >= 86400)
		$format[] = '%a day' . ($seconds > 86400 * 2 ? 's' : '');
	if ($seconds >= 3600)
		$format[] = '%h hour' . ($seconds > 3600 * 2 ? 's' : '');
	if ($seconds >= 60)
		$format[] = '%i minute' . ($seconds > 60 * 2 ? 's' : '');
	$format[] = '%s ' . ($seconds !== 1 ? 'seconds' : 'second');

	$dateHandle = new DateTime('@0');
	return str_replace(' 1 seconds', ' 1 second', $dateHandle->diff(new DateTime("@$seconds"))->format(implode(', ', $format)));
}

function callAPI(string $type, string $url, array $parameters = array())
{
	$type = strtoupper($type);
	if ($type === 'GET')
		$url = $url . '?' . http_build_query($parameters);

	$curlHandle = curl_init($url);

	if ($type === 'POST')
	{
		curl_setopt($curlHandle, CURLOPT_POST, 1);
		curl_setopt($curlHandle, CURLOPT_POSTFIELDS, json_encode($parameters));
	}

	curl_setopt($curlHandle, CURLOPT_HTTPHEADER, ['Content-Type:application/json']);
	curl_setopt($curlHandle, CURLOPT_RETURNTRANSFER, true);
	$response = curl_exec($curlHandle);
	curl_close($curlHandle);
	return $response;
}


function rotate(array $array): array
{
	array_unshift($array, null);
	$array = call_user_func_array('array_map', $array);
	$array = array_map('array_reverse', $array);
	return $array;
}

function flattenSingleArrays(array $array): array
{
	foreach ($array as $key => &$value)
	{
		if (!is_array($value))
			continue;
		elseif (count($value) === 1)
			$array[$key] = $value[0];
		elseif (count($value) > 1)
			$array[$key] = flattenSingleArrays($value);
	}
	return $array;
}

function flatten(array $array): array
{
	$return = array();
	array_walk_recursive($array, function ($a) use (&$return)
	{
		$return[] = $a;
	});
	return $return;
}

/**
 * Caches a function result to a $GLOBALS['cache'] array.
 * This is useful for queries that are run frequently in a single script and often request the same data.  
 * The cache is stored in a global array and is keyed by the function and the parameters passed to the function.  
 * It's important to note that the cache is only valid for the current script and changed data will not be reflected.
 *
 * @param callable $function
 * @param mixed ...$params
 * @return mixed
 */
function cachedFunction(callable $function, mixed ...$params): mixed
{
	if (!isset($GLOBALS['cache'][$function][implode('', $params)]))
		$GLOBALS['cache'][$function][implode('', $params)] = call_user_func($function, ...$params);

	return $GLOBALS['cache'][$function][implode('', $params)];
}

function readCSVFile(string $filePath, int $length = null, string $separator = ',', string $enclosure = '"', string $escape = '\\'): \Generator | false
{
	$header = null;
	$file = fopen($filePath, 'r');
	if ($file === false)
		return false;

	while (($row = fgetcsv($file, $length, $separator, $enclosure, $escape)) !== false)
	{
		if ($header === null) //First row is the header
			$header = $row;
		else //Subsequent rows are data
		{
			$rowData = array_combine($header, $row);
			yield $rowData;
		}
	}

	fclose($file);
}

/**
 * Computes the hash of provided file paths
 * 
 * Provides 3 keys:
 * - `hash`: Binary hash generated by the file.
 * - `integrity`: Formatted integrity value with base64 encoded hash prepended by the algorithm.
 * - `version`: The last section of the base64 encoded hash (without the trailing equal signs) that is URL encoded for appending to URLs.
 *
 * @param array $filePaths
 * @param string $hash - The `integrity` attribute only supports `sha256`, `sha384`, and `sha512`
 * @return void
 */
function versionedFiles(array $filePaths, int $versionLength = 6, string $hash = 'sha512')
{
	$output = [];
	foreach ($filePaths as $filePath)
	{
		$output[$filePath]['hash'] = hash($hash, file_get_contents($filePath), true); //Computing hash.
		$output[$filePath]['integrity'] = $hash . '-' . base64_encode($output[$filePath]['hash']); //Creating integrity value.
		$output[$filePath]['version'] = urlencode(substr($output[$filePath]['integrity'], -$versionLength - 2, $versionLength)); //Getting last few characters as a version.
	}
	return $output;
}

function convertBoolStringToBool(string $value): bool
{
	return (strtolower(trim($value)) === 'true' ? true : false);
}

function runCommand(string $command): array | false
{
	// Prepare the descriptors for process communication
	$descriptors = [
		0 => ['pipe', 'r'], // stdin
		1 => ['pipe', 'w'], // stdout
		2 => ['pipe', 'w'] // stderr
	];

	// Open the process
	$process = proc_open($command, $descriptors, $pipes);

	if (is_resource($process))
	{
		// Close the stdin pipe (we don't need to write to it)
		fclose($pipes[0]);

		// Read from the stdout pipe
		$stdout = stream_get_contents($pipes[1]);
		fclose($pipes[1]);

		// Read from the stderr pipe
		$stderr = stream_get_contents($pipes[2]);
		fclose($pipes[2]);

		// Close the process
		$returnValue = proc_close($process);

		// Return the result
		return [
			'stdout' => $stdout,
			'stderr' => $stderr,
			'return_value' => $returnValue
		];
	}
	else
		return false;
}

function downloadArrayAsCSV(array $array, string $filename = 'output', string $delimiter = ',')
{
	// open raw memory as file so no temp files needed, you might run out of memory though
	$file = fopen('php://memory', 'w');

	//Create header line.
	fputcsv($file, array_keys($array[0]), $delimiter);

	// loop over the input array
	foreach ($array as $line)
	{
		// generate csv lines from the inner arrays
		fputcsv($file, $line, $delimiter);
	}
	// reset the file pointer to the start of the file
	fseek($file, 0);
	// tell the browser it's going to be a csv file
	header('Content-Type: text/csv');
	// tell the browser we want to save it instead of displaying it
	header('Content-Disposition: attachment; filename="' . $filename . '.csv";');
	// make php send the generated csv lines to the browser
	fpassthru($file);
}

function outputFile(string $filePath, string $outputName, string $contentType = 'binary')
{
	if (!is_file($filePath))
	{
		http_response_code(404);
		echo 'File not found.';
		return false;
	}
	header('Content-Type: ' . $contentType);
	header('Content-Transfer-Encoding: binary');
	header('Content-Disposition: attachment; filename="' . $outputName . '";');
	header('Content-Length: ' . filesize($filePath));

	// Clear output buffer
	if (ob_get_level())
	{
		ob_end_clean();
	}

	// Open file and stream content
	$fp = fopen($filePath, 'rb');
	if ($fp === false)
	{
		http_response_code(500);
		echo 'Error opening file.';
		return false;
	}

	// Output file content in chunks
	while (!feof($fp))
	{
		echo fread($fp, 8192);
		flush(); // Ensure content is sent to the browser immediately
	}

	fclose($fp);
}
